# -*- coding: utf-8 -*-
"""Copia de CST Element Extended FEM course.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WqUmKAfO1lMsgLJUvXIHQ2IyUJf1zQSR
"""

'''
Our workflow will be as follows:
1. Geometry
2. Material Properties
3. Stiffness Matrix Properties
4. Boundary Conditions
5. Linear Solution
'''
import numpy as np

#========================================================
#1. GEOMETRY
'''

   3(0,1)
   ___________ 2(1,1)
===|         /|
===|        / |
===|       /  |
===|      /   |
===|     /    |
===|    /     |
===|   /      |
===|  /       |
===| /        |
===|/_________|
   0(0,0)     1(1,0)

For the nodes and elements, we create separate arrays containing the x and y coordinates
of the nodes and then the node number of each element.
To successfully the x-coordinate of node 0, we write:
x0 = nodes[0, 0] and so on.
'''

nodes = np.array([
    [0, 0],  # Node 0
    [1, 0],  # Node 1
    [1, 1],  # Node 2
    [0, 1],  # Node 3
])

elements = np.array([
    [0, 1, 2],  # Element 1
    [2, 3, 0],  # Element 2
])

#========================================================
#2. MATERIAL PROPERTIES
'''
Here we define the :
nu = Poissons ratio of concrete
E = Young's Modulus of concrete
D = strain displacement matrix

'''
E = 30e9
nu = 0.3

# Plane strain D matrix
'''
D is the strain displacement matrix (PLANE STRAIN CONDITION)
'''
D = (E / ((1 + nu) * (1 - 2 * nu))) * np.array([
              [1 - nu, nu, 0],
              [nu, 1 - nu, 0],
              [0, 0, (1 - 2 * nu) / 2],
])

#========================================================
# 3. FUNCTION DEFINITIONS (AREA, B MATRIX, STRAINS, STRESSES)
'''
The area of the triangle is dependent on the:
1. Coordinates of the nodes
2. The element in question

We create the function in such a way that it takes in an element
and its nodes. This helps us to later loop over all the elements, instead
of creating an area calculation for each element('for element in elements')

'''
def calculate_area_triangle(element, nodes):
    #WE START BY COLLECTING THE X AND Y COORDINATES FOR EACH ELEMENT
    coordinates = nodes[element]

    #WE ASSIGN EACH COORDINATE TO A VARIBLE
    x0, y0 = coordinates[0]
    x1, y1 = coordinates[1]
    x2, y2 = coordinates[2]

    area = 0.5 * abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1))
    return area

'''
The B matrix is calculated so:

B = (1/2A)* [(y1-y2),       0,   (y2-y0),       0,   (y0-y1),    0
               0    ,   x2-x1,         0,   x0-x2,         0,    x1-x0
               x2-x1,   y1-y2,     x0-x2,   y2-y0,     x1-x0,    y0-y1]

]


'''
def calculate_B_matrix(element, nodes):
    #WE START BY COLLECTING THE X AND Y COORDINATES FOR EACH ELEMENT
    coordinates = nodes[element]

    #WE ASSIGN EACH COORDINATE TO A VARIBLE
    x0, y0 = coordinates[0]
    x1, y1 = coordinates[1]
    x2, y2 = coordinates[2]

    #WE USE THE PREVIOUS FUNCTION TO CALCULATE THE AREA
    A = calculate_area_triangle(element, nodes)

    #WE SIMPLY THE CODE BY PUTTING INTO AN ARRAY AND ASSIG NING IT LETTERS
    b = np.array([y1 - y2, y2 - y0, y0 - y1])
    c = np.array([x2 - x1, x0 - x2, x1 - x0])

    B = (1 / (2 * A)) * np.array([
        [b[0], 0, b[1], 0, b[2], 0],
        [0, c[0], 0, c[1], 0, c[2]],
        [c[0], b[0], c[1], b[1], c[2], b[2]]
    ])
    return B

'''
the strain equation is
epsilon = B @ u(local)

'''
def calculate_strains(elements, nodes, displacements):

  strains = []
  for element in elements:
    #DOF MAPPING
    dof_map = np.concatenate([2 * element, 2 * element + 1])
    #RETRIEVING THE LOCAL DISPLACEMENTS FROM THE ELEMENT
    local_displacement = displacements[dof_map]
    #we need the B matrix
    B = calculate_B_matrix(element, nodes)

    #finally, we can calculate the strains
    epsilon = B @ local_displacement


    strains.append(epsilon)
    #we can also write return strains but outputing it as a np.array is
    #better for manipulation
  return np.array(strains)

'''
the equation is:
sigma = D @ strains
'''
def calculate_stress(strains, D):
  #we initiate a list to store the stresses for each element
  stresses = []


  for strain in strains:
    sigma = D @ strain
    stresses.append(sigma)

  #we can also write return stresses but outputing it as a np.array is
  #better for manipulation
  return np.array(stresses)

#====================================================
# 4. GLOBAL STIFFNESS MATRIX ASSEMBLY
'''
We first find the local stiffness matrix for each element
the map into the global stiffness matrix.

K = (B.T@D@B) * A

IMPORTANT NOTE:
In the equation, we integrate this over the surface(triangle) which
is the same as the area.

The number of degrees of freedom is also to be considered. Since every
node has two coordinates(x and y), we take the len of the node array and multiply
by 2

The dimensions(shape) of K are dependent on the number of degrees of
freedom
'''
#WE COLLECT THE DEGREES OF FREEDOM
number_of_dof = 2 * len(nodes)

#WE INITIATE THE K GLOBAL WITH ZEROS AND WITH DIMENSIONS BASED ON THE DOFS
K_global = np.zeros((number_of_dof, number_of_dof))


for element in elements:
    A = calculate_area_triangle(element, nodes)
    B = calculate_B_matrix(element, nodes)
    K_local = (B.T @ D @ B) * A

    #MAPPING FUNCTION
    # Map local stiffness to global stiffness matrix
    dof_map = np.ravel([[2 * node, 2 * node + 1] for node in element])
    #dof_map = np.concatenate([2 * element, 2 * element + 1])
    for i in range(6):
        for j in range(6):
            K_global[dof_map[i], dof_map[j]] += K_local[i, j]



#====================================================
# 5. BOUNDARY CONDITIONS
'''
The following boundary conditions are imposed:
1. Node 0 and node 3 are clamped/fixed therefore no displacement is assumed.
2. Node 1 and 2 are free to move.
3. Node 1 and 2 have 1000N forces applied to them in positive x-direction.
'''
#Initiating the Force vector with 0s. Its dimension are based on the degree of freedom
F_global = np.zeros(number_of_dof)
# External force at Node 1 in x-direction
F_global[2] = 1000.0
# External force at Node 2 in x-direction
F_global[4] = 1000.0

#We create a list to identify the nodes with our BCs
#the first and last two nodes are fixed so:
fixed_dofs = [0, 1, 6, 7] #list of dofs (8 nodes)

#assigning the corresponding BCs to the nodes
for dof in fixed_dofs:
    K_global[dof, :] = 0
    K_global[:, dof] = 0
    K_global[dof, dof] = 1
    F_global[dof] = 0

#========================================================
# 6. LINEAR SOLUTIONS
'''
We calculate the displacements, strains and stress.
Ku = F
strain_epsilon = B@u
stress_sigma = D@strain_epsilon

since we have already defined functions to find the strains and stresses,
we can use them here.
'''

displacements = np.linalg.solve(K_global, F_global)
strains = calculate_strains(elements, nodes, displacements)
stresses = calculate_stress(strains, D)



# OUTPUT RESULTS
print("Global Stiffness Matrix (K):")
print(K_global)

print("\nGlobal Force Vector (F):")
print(F_global)

print("\nNodal Displacements (u):")
print(displacements)


for i, (strain, stress) in enumerate(zip(strains, stresses)):
    print(f"Element {i + 1}:")
    print(f"  Strain: {strain}")
    print(f"  Stress: {stress}")



